---
import type { CollectionEntry } from "astro:content";

type Props = {
  project: CollectionEntry<"projects">;
};

const { project } = Astro.props;
const { data } = project;

// Rearrange images to alternate left and right from the center
type ImageType = string | { src: string; caption?: string };

function alternateImages(images: ImageType[]) {
  if (images.length === 0) return [];
  const result = [images[0]];
  const left: ImageType[] = [];
  const right: ImageType[] = [];
  for (let i = 1; i < images.length; i++) {
    if (i % 2 === 1) {
      right.push(images[i]);
    } else {
      left.unshift(images[i]);
    }
  }
  return [...left, ...result, ...right];
}

const images: ImageType[] = alternateImages(data.images);
const leftCount = Math.floor((data.images.length - 1) / 2);
const previewImage = images[leftCount];
---

<li class="mb-6">
  <div
    id={"slider-" + project.slug}
    class="slider w-screen relative inset-x-1/2 mx-[-50vw] overflow-hidden flex"
    data-images={JSON.stringify(images)}
    data-center-index={leftCount}
    style="height: 25vh;"
  >
    <div class="h-full">
      <div
        id={"slides-" + project.slug}
        class="flex flex-row h-full items-center"
        style="will-change: transform; transform-origin: center center;"
      >
        {
          images.map((image, i) => (
            <figure 
              class="relative flex mx-2 transition-opacity duration-300 h-full shrink-0"
              style={i !== leftCount ? "opacity: 0; pointer-events: none;" : "opacity: 1;"}
            >
              <img
                src={typeof image === "string" ? image : image.src}
                alt={data.title}
                class="object-contain h-full"
                style="display: block;"
              />
              {typeof image !== "string" && image.caption && (
                <figcaption
                  class="relative ml-2 mt-auto text-s inline-block caption-toggle select-none opacity-40 max-w-30 text-wrap"
                  data-caption={image.caption}
                >
                  [...]
                </figcaption>
              )}
            </figure>
          ))
        }
      </div>
    </div>
  </div>
  <div
      class="w-screen relative inset-x-1/2 mx-[-50vw] py-2 cursor-ns-resize flex items-center justify-center group"
      id={"resize-handle-" + project.slug} 
      style="z-index: 10;">
      <div class="w-16 h-1 bg-gray-300 group-hover:bg-gray-500 rounded-full transition-all duration-200 group-hover:h-1.5"></div>
  </div>
  <div class="grid grid-cols-6 items-center">
    <h2 class="uppercase col-span-3 project-title">{data.title}</h2>
    <p class="col-span-2">{data.categories}</p>
    <p class="text-right">{data.year}</p>
    <p class="col-span-6 mt-1">{project.body}</p>
  </div>
</li>

<script is:inline define:vars={{ project, previewImage }}>
  document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById(`slider-${project.slug}`);
    const slides = document.getElementById(`slides-${project.slug}`);
    const resizeHandle = document.getElementById(`resize-handle-${project.slug}`);

    if (!slider || !slides || !resizeHandle) return;

    const slideImgs = Array.from(slides.children);
    const totalImages = slideImgs.length;
    const centerIndex = parseInt(slider.getAttribute("data-center-index"), 10) || 0;
    
    let isResizing = false;
    let startY = 0;
    let startHeight = 0;
    let index = centerIndex;
    let expanded = false;
    let currentTransformX = 0;
    let justFinishedResizing = false;

    // --- HELPER FUNCTIONS ---

    function getSide(e) {
      const rect = slider.getBoundingClientRect();
      return e.clientX - rect.left < rect.width / 2 ? "left" : "right";
    }

    function showAllImages(fade = true) {
        slides.querySelectorAll("figure").forEach((fig, i) => {
            fig.style.pointerEvents = "auto";
            if (fade && i !== index) {
                fig.style.transition = "opacity 0.5s";
                fig.style.opacity = "0";
                setTimeout(() => { fig.style.opacity = "1"; }, 10);
            } else {
                fig.style.opacity = "1";
            }
        });
        expanded = true;
    }

    function showPreviewOnly(instant = false) {
        slides.querySelectorAll("figure").forEach((fig, i) => {
          if (instant) {
            fig.style.transition = "none";
          } else {
            fig.style.transition = "opacity 0.5s";
          }
          fig.style.pointerEvents = (i === centerIndex) ? "auto" : "none";
          fig.style.opacity = (i === centerIndex) ? "1" : "0";
          if (instant) {
            setTimeout(() => { fig.style.transition = "opacity 0.5s";
            }, 50);
          }
        });
        expanded = false;
        index = centerIndex;
    }

    function resetCaptions() {
      slides.querySelectorAll("figcaption").forEach((caption) => {
        caption.textContent = "[...]";
      });
    }

    // --- CORE CENTERING LOGIC --

    function calculateCenterPosition() {
        if (!slideImgs[index]) return 0;

        let offset = 0;
        for (let i = 0; i < index; i++) {
            const fig = slideImgs[i];
            const img = fig.querySelector("img");
            if (img) {
                const imgWidth = img.getBoundingClientRect().width;
                const style = getComputedStyle(fig);
                const marginLeft = parseInt(style.marginLeft || 0);
                const marginRight = parseInt(style.marginRight || 0);
                offset += imgWidth + marginLeft + marginRight;
            }
        }

        const currentImg = slideImgs[index].querySelector("img");
        if (!currentImg) return 0;

        const sliderCenter = slider.offsetWidth / 2;
        const imgCenter = currentImg.getBoundingClientRect().width / 2;

        return sliderCenter - offset - imgCenter;
    }

    function updateSlider(smooth = true) {
        currentTransformX = calculateCenterPosition();
        
        if (smooth) {
            slides.style.transition = "transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
        } else {
            slides.style.transition = "none";
        }

        slides.style.transform = `translateX(${currentTransformX}px)`;

        resetCaptions();
    }

    // --- EVENT LISTENERS ---

    // --- RESIZE HANDLING WITH SMOOTH CENTERING ---
    resizeHandle.addEventListener("mousedown", (e) => {
      isResizing = true;
      startY = e.clientY;
      startHeight = slider.offsetHeight;
      document.body.style.cursor = "ns-resize";
      document.body.style.userSelect = "none";
      
      slides.style.transition = "none";
      
      e.preventDefault();
    });

    document.addEventListener("mousemove", (e) => {
      if (!isResizing) return;
      
      const dy = e.clientY - startY;
      
      const minHeight = 100;
      const maxHeight = window.innerHeight * 0.5;
      const newHeight = Math.max(minHeight, Math.min(startHeight + dy, maxHeight));
      
      slider.style.height = `${newHeight}px`;

      requestAnimationFrame(() => {
        updateSlider(false);
      })
    });

    document.addEventListener("mouseup", () => {
      if (isResizing) {
        isResizing = false;
        document.body.style.cursor = "";
        document.body.style.userSelect = "";

        justFinishedResizing = true;
        setTimeout(() => { justFinishedResizing = false; }, 100);

        slides.style.transition = "transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)";

        setTimeout(() => updateSlider(true), 10);
      }
    });

    let resizeTimeout;
    const resizeObserver = new ResizeObserver(() => {
        if (!isResizing) {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateSlider(false);
            }, 16);
        }
    });
    resizeObserver.observe(slider);

    // SLIDER INTERACTION
    slider.addEventListener("click", (e) => {
        if (justFinishedResizing) {
          return;
        }

        if (!expanded) {
            showAllImages(true);
            setTimeout(() => updateSlider(true), 50);
            return;
        }

        if (e.target.closest('figure')) {
            const figcaption = e.target.closest('figcaption');
            if (figcaption) {
                e.stopPropagation();
                if (figcaption.textContent === "[...]") {
                    figcaption.textContent = `[${figcaption.getAttribute("data-caption")}]`;
                } else {
                    figcaption.textContent = "[...]";
                } 
                return;
            }
        }

        if (getSide(e) === "left") {
            index = (index - 1 + totalImages) % totalImages;
        } else {
            index = (index + 1) % totalImages;
        }
        updateSlider();
    });

    // CURSOR MANAGEMENT    
    slider.addEventListener("mousemove", (e) => {
        if (!expanded) slider.style.cursor = "crosshair";
        else slider.style.cursor = getSide(e) === "left" ? "w-resize" : "e-resize";
    });

    slider.addEventListener("mouseleave", () => {
        slider.style.cursor = "default";
    });

    let windowResizeTimeout;
    window.addEventListener("resize", () => {
        clearTimeout(windowResizeTimeout);
        windowResizeTimeout = setTimeout(() => {
            updateSlider(false);
        }, 100);
    });

    document.addEventListener("click", (e) => {
        if (expanded && !slider.contains(e.target)) {
            showPreviewOnly();
            setTimeout(() => updateSlider(true), 50);
        }
    });

    window.addEventListener("sliderSizeChange", (event) => {
      const newHeight = event.detail.height;
      if (slider && typeof newHeight === "number") {
        slider.style.height = `${newHeight}px`;
        setTimeout(() => {
          requestAnimationFrame(() => updateSlider(false));
        }, 500);
      }
    })

    // INITIALIZATION
    showPreviewOnly(true);
    requestAnimationFrame(() => {
        updateSlider(false);
    });
  });
</script>
